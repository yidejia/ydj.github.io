<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>经传技术博客</title>
  <subtitle>自驱自律自组织</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yidejia.github.io/"/>
  <updated>2016-11-29T01:49:57.000Z</updated>
  <id>https://yidejia.github.io/</id>
  
  <author>
    <name>经传技术部</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS - 优先队列的三种实现方式</title>
    <link href="https://yidejia.github.io/2016/11/29/caokun_priority_queue/"/>
    <id>https://yidejia.github.io/2016/11/29/caokun_priority_queue/</id>
    <published>2016-11-29T08:12:55.000Z</published>
    <updated>2016-11-29T01:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在做一个APP的聊天功能，聊天消息走socket推过来的，每个消息有唯一的id，id随时间是增大的，聊天消息要按时间有序，不重复，不遗漏。</p>
<p>本博客主要想说消息有序，但提到了不重复，不遗漏，也简单说一下。<br><strong>不遗漏</strong>：一种方式就是本地保存最新的消息id，请求最新数据时带上这个id，等到请求回来，才能更新最新id，注意一下边界开区间闭区间的问题就可以了，服务器应该返回 ( 本地最新id, 服务器最新id ]，这种左开右闭的区间给客户端就行。还有一种保证消息100%到达的应用层应答机制，可以在我之前的博客看到<a href="http://www.jianshu.com/p/edb50afa250e" target="_blank" rel="external">点击查看</a>。</p>
<p><strong>不重复</strong>：有时候移动网络很差，一个请求发出去很久才响应，中间可能隔了几秒钟，这个时候，有些用户很急可能会狂点界面，比如我，导致请求重复发（实际中已做限频，狂点也不会发请求），然后回来的消息自然就有很多重复了。去重很简单了，OC 中用 NSMutableDictionary，底层是哈希表，把消息id 作为 key，加入到字典中再拿出来，重复的就没有了。但实际中数据量较小，你写两个 for 循环去重也不会有什么性能问题，理论上会更耗cpu和电量。</p>
<h1 id="消息有序"><a href="#消息有序" class="headerlink" title="消息有序"></a>消息有序</h1><p>第一的想法是每次收到新的消息就加入到优先队列中，然后一出队就全部都是有序的了。但是 oc 中没有优先队列这种结构，甚至连队列都没有，一个变通的做法就是用 NSMutableArray 来实现队列和栈，但是用法很别扭，如果 NSMutableArray 用数组实现的话，会有大量的位移操作，效率会很低。</p>
<p>一开始我把消息保存到 NSArray 中，每次来了新消息都执行排序+去重的操作来保证有序，数据量小就没什么问题，其实也不小，群里面聊天几十个人同时发消息，一下就重复好多次这样的操作。后来比较有空，就自己用 oc 实现了一个优先队列，方便使用，效率高，大量数据下性能也很好。</p>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>普通队列是先进先出的结构，优先队列是一种按照优先级大小，比如小的先出队，的一种结构。所以先进的不一定先出，它会把优先级高的先出，下面我认为id小的优先级高。要先出队。</p>
<p>举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">入队元素顺序：2, 3, 4, 5, 1</div><div class="line"></div><div class="line">普通队列出队：2, 3, 4, 5, 1</div><div class="line">优先队列出队：1, 2, 3, 4, 5  (有序)</div></pre></td></tr></table></figure></p>
<p>那么如何实现优先队列？有以下三种方法</p>
<h3 id="1-入队有序"><a href="#1-入队有序" class="headerlink" title="1.入队有序"></a>1.入队有序</h3><p>就是每加入一个元素的时候，把它移到一个“合适”的位置，举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">队列中已经有 1, 3, 4，现在要加入 2</div><div class="line">那么把 2 移到 1，3 的中间，就是 1, 2, 3, 4</div><div class="line">这个“合适”的位置定义为：前一个元素 &lt;= 要加入的元素 &lt;= 后一个元素</div></pre></td></tr></table></figure></p>
<p>入队已经保证有序了，那么出队就直接把第一个元素拿出来，就是最小的了。<br>显然 n 个元素的时间复杂度，入队操作 O(n)，出队操作 O(1)<br>缺点：该方法，如果有大量的入队操作比较耗时。</p>
<h3 id="2-遍历最小的出队"><a href="#2-遍历最小的出队" class="headerlink" title="2.遍历最小的出队"></a>2.遍历最小的出队</h3><p>因为方法1的入队操作耗时，那么方法2做了个改进，入队的时候什么也不做，直接追加到尾部，出队时候去遍历数组中最小的元素出队，举个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">队列中已经有 3, 1, 4，现在要加入 2</div><div class="line">那么把 2 加到尾部，就是 3, 1, 4, 2</div></pre></td></tr></table></figure></p>
<p>出队的时候，遍历数组，找到最小的元素1，出队就行了<br>显然，入队操作 O(1)，出队操作 O(n)<br>缺点：如果有大量出队操作比较耗时</p>
<h3 id="3-二叉堆"><a href="#3-二叉堆" class="headerlink" title="3.二叉堆"></a>3.二叉堆</h3><p>由于上面两种方法都有缺点，最后用<strong>堆</strong>这种数据结构来实现优先队列</p>
<h4 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h4><p>如下图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2764502-2ee3dc6c142c9e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="heap"></p>
<p>入队操作，向堆中加入一个元素</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2764502-e93110fa7478b723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add"></p>
<p>出队操作，从堆中删掉一个元素</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2764502-833c0d3248547a8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="del"></p>
<p>用堆来实现优先队列，入队，出队操作复杂度 O(log n)，比较平衡。</p>
<p>最后还是上个 oc 写的代码吧（<a href="https://github.com/hehe520/CKDataStructureKit" target="_blank" rel="external">下载地址</a>），顺便吐槽一下 c++, java 都 priority_queue 这样的数据结构，oc 居然没有，得自己用 NSMutableArray 模拟，或者自己写一个。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;在做一个APP的聊天功能，聊天消息走socket推过来的，每个消息有唯一的id，id随时间是增大的，聊天消息要按时间有序，不重复，不遗漏。&lt;
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="曹堃" scheme="https://yidejia.github.io/tags/%E6%9B%B9%E5%A0%83/"/>
    
      <category term="iOS" scheme="https://yidejia.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一句代码实现标题栏、导航栏滑动隐藏，ByeBurger库的使用和实现</title>
    <link href="https://yidejia.github.io/2016/11/07/wing_byeburger/"/>
    <id>https://yidejia.github.io/2016/11/07/wing_byeburger/</id>
    <published>2016-11-07T03:13:23.000Z</published>
    <updated>2016-11-29T01:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>ByeBuger是一个能够让你快速实现标题栏以及底部导航栏在滑动时隐藏的库。本文将介绍ByeBuger的使用和实现。</p>
<p>现在，ByeBuger可以轻易地将<strong>任何view</strong>在滑动的时候隐藏或者显示。同时支持头部(标题栏)和底部(导航栏)效果。</p>
<p><a href="https://github.com/githubwing/ByeBurger" target="_blank" rel="external">ByeBurger项目地址</a></p>
<p>先看一下全新的效果：</p>
<p><img src="http://ac-mhke0kuv.clouddn.com/56781ae4da8c044aceec.gif" alt=""></p>
<p><img src="http://ac-mhke0kuv.clouddn.com/fff0d5a7d0a1b1dfcbb1.gif" alt=""></p>
<p>还不错吧。然而，实现这么炫酷的效果，<strong>仅仅需要一句代码！</strong></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1.在gradle 编译库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">   compile &apos;com.github.githubwing:ByeBurger:1.1.0&apos;</div><div class="line">  compile &apos;com.android.support:design:25.0.0&apos;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>2.<strong>你仅仅需要一句代码，对，没错，只需要在你的View上加入一句。</strong><br>先使用CoordinatorLayout作为根布局,然后向你的<strong>任何</strong>View中插入一句app:layout_behavior属性，即可实现滑动的隐藏和显示。<br>你的标题栏可以是Toolbar或者LinearLayout或者什么鬼。<br>同样你的底部导航栏可以是最新的BottomNavigationView亦或者TabLayout在古老一点的RadioButton都可以！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></div><div class="line"> </div><div class="line">  <span class="tag">&lt;<span class="name">Viewpager</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">Toolbar</span></span></div><div class="line">  	<span class="attr">app:layout_behavior</span>=<span class="string">"@string/bye_burger_title_behavior"</span></div><div class="line">  /&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">BottomTab</span> </span></div><div class="line">   <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></div><div class="line">   <span class="attr">app:layout_behavior</span>=<span class="string">"@string/bye_burger_bottom_behavior"</span></div><div class="line">  /&gt;      </div><div class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>具体的一句话是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">对于标题栏</div><div class="line">app:layout_behavior=&quot;@string/bye_burger_title_behavior&quot;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">对于底部导航栏</div><div class="line">app:layout_behavior=&quot;@string/bye_burger_bottom_behavior&quot;</div></pre></td></tr></table></figure>
<p>之后你就可以让你的app享受更多的阅读空间啦，相信这给用户带来了极大的便利。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>CoordinatorLayout类似于FrameLayout，所以注意xml层次，TitleBar和BottomTab要在xml下方。<br>只有实现NestScorll接口View的才可以实现监听，例如RecyclerView、NestScrollView.<br>在ListView下，是不生效的。</p>
<p><a href="https://github.com/githubwing/ByeBurger" target="_blank" rel="external">ByeBurger项目地址</a></p>
<p>以上就是ByeBurger的使用方式，接下来将会介绍ByeBurger的实现方式。如果你只是使用或者不感兴趣就不用往下看啦~~不过我还是建议你看一看，因为知道一个轮子的原理，百利无一害。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h3 id="0-改名原因"><a href="#0-改名原因" class="headerlink" title="0.改名原因"></a>0.改名原因</h3><p>在ByeBurger 1.0版本的时候，其实ByeBurger不叫ByeBurger的，而叫做ByeBurgerNavigationView, 由名字可以看出，他是扩展了系统的BottomNavigationView，可是这样做有许多弊端，比如强制用户使用了某个控件，这样通用性不强。第二，为了用户有更多的选择，加入了头部隐藏效果。所以说，这个项目已经不能被称为NavigationView。于是我将名称进行了修改。</p>
<h3 id="1-历史实现"><a href="#1-历史实现" class="headerlink" title="1.历史实现"></a>1.历史实现</h3><p>在1.0版本，我继承了BottomNavigationView。提供了两个方法，一个是show,另一个是hide.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    setY(mStartY);</div><div class="line">    TranslateAnimation ta = <span class="keyword">new</span> TranslateAnimation(<span class="number">0f</span>, <span class="number">0f</span>,getMeasuredHeight(),<span class="number">0</span>);</div><div class="line">    ta.setDuration(<span class="number">300</span>);</div><div class="line">    ta.setAnimationListener(<span class="keyword">this</span>);</div><div class="line">    startAnimation(ta);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">    setY(mStartY + getMeasuredHeight());</div><div class="line"></div><div class="line">    TranslateAnimation ta = <span class="keyword">new</span> TranslateAnimation(<span class="number">0f</span>, <span class="number">0f</span>, -getMeasuredHeight(), getMeasuredHeight());</div><div class="line">    ta.setDuration(<span class="number">300</span>);</div><div class="line">    ta.setAnimationListener(<span class="keyword">this</span>);</div><div class="line">    startAnimation(ta);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>实际上就是对Y坐标进行了一些处理。给个动画再让他改变他的Y坐标。来达到隐藏效果。(总之隐藏就是让用户看不到)</p>
<p>然后利用Behavior，对NestScroll相关滑动进行监听，来改变ByeBurgerNavigationView的状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByeBurgerBehavior</span> <span class="keyword">extends</span> <span class="title">CoordinatorLayout</span>.<span class="title">Behavior</span>&lt;<span class="title">ByeBurgerNavigationView</span>&gt; </span>&#123;</div></pre></td></tr></table></figure></p>
<p>当然，这是1.0的实现，实用性比较低。所以有了1.1.0版本。</p>
<h3 id="2-更新实现"><a href="#2-更新实现" class="headerlink" title="2.更新实现"></a>2.更新实现</h3><p>整体思路就是利用自定义behavior去监听nestScroll的滑动，来让对应的View改变。之前在<a href="http://androidwing.net/index.php/70" target="_blank" rel="external">CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你撸三款！</a> 中介绍过一种Behavior的使用方式，不熟悉的可以先过去看看。这里用到的是第二种，主要是针对NestScroll进行监听。</p>
<p>首先，要自定义一个Behavior，他的泛型，也就是child view为View。 这也保证了它的通用性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByeBurgerBottomBehavior</span> <span class="keyword">extends</span> <span class="title">CoordinatorLayout</span>.<span class="title">Behavior</span>&lt;<span class="title">View</span>&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其次来处理一下onStartNestedScroll()方法，他提供一个返回值，用于过滤掉滑动事件。这里我们只关心上下滑动。所以应该这样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child,</span></span></div><div class="line">      View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="number">0</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>最后，在onNestedPreScroll()进行child的对应操作。首先要根据参数dy来判断上下滑动,然后再根据view当前的状态来显示或者隐藏目标View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child, View target,</span></span></div><div class="line">      <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed) &#123;</div><div class="line">	<span class="comment">//初始化一些参数</span></div><div class="line">    <span class="keyword">if</span> (isFirstMove) &#123;</div><div class="line">      isFirstMove = <span class="keyword">false</span>;</div><div class="line">      mAnimateHelper = AnimateHelper.get(child);</div><div class="line">      mAnimateHelper.setStartY(child.getY());</div><div class="line">      mAnimateHelper.setMode(AnimateHelper.MODE_BOTTOM);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (Math.abs(dy) &gt; mTouchSlop) &#123;</div><div class="line">      <span class="keyword">if</span> (dy &lt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mAnimateHelper.getState() == AnimateHelper.STATE_HIDE) &#123;</div><div class="line">          mAnimateHelper.show();</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mAnimateHelper.getState() == AnimateHelper.STATE_SHOW) &#123;</div><div class="line">          mAnimateHelper.hide();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面函数里，view的隐藏和显示委托给了AnimateHelper类。这是一个Helper，用来管理View的状态，也就是托付View隐藏或者显示。他的代码很简单，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimateHelper</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> View mTarget;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">float</span> mStartY;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_SHOW = <span class="number">1</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATE_HIDE = <span class="number">0</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> mCurrentState = STATE_SHOW;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> mMode = MODE_TITLE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MODE_TITLE = <span class="number">233</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MODE_BOTTOM = <span class="number">2333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提供一些成员，用于保存 状态，模式，起始Y坐标等等。</p>
<p>提供一个工厂方法，用于获得处理目标view的helper:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AnimateHelper <span class="title">get</span><span class="params">(View target)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> AnimateHelper(target);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>之后，提供show方法和hide方法，用于执行view的隐藏或者显示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mMode == MODE_TITLE) &#123;</div><div class="line">      showTitle();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mMode == MODE_BOTTOM) &#123;</div><div class="line">      showBottom();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mMode == MODE_TITLE) &#123;</div><div class="line">      hideTitle();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mMode == MODE_BOTTOM) &#123;</div><div class="line">      hideBottom();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>而 showTitle()和 showBottom()之类的如1.0版一样，是改变了一下y坐标，然后执行动画。</p>
<h2 id="如何让用户使用"><a href="#如何让用户使用" class="headerlink" title="如何让用户使用"></a>如何让用户使用</h2><p>这里参考了系统预留behavior的使用方式，由于Behavior实例是系统反射出来的，所以需要完整的包名。于是我就将Beavior的包名写在了string.xml里，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"bye_burger_bottom_behavior"</span>&gt;</span>com.wingsofts.byeburgernavigationview.ByeBurgerBottomBehavior<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"bye_burger_title_behavior"</span>&gt;</span>com.wingsofts.byeburgernavigationview.ByeBurgerTitleBehavior<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>所以用户使用起来及其简便，只需要在xml中给view加入一行代码app:layoutbehavior=”@string/byeburgerbottom_behavior”即可。</p>
<p>以上，ByeBurger库的使用和实现就写完了。</p>
<p>如果你觉得还不错 欢迎star, 更欢迎贡献代码。</p>
<p>本库下载地址：<a href="https://github.com/githubwing/ByeBurger" target="_blank" rel="external">https://github.com/githubwing/ByeBurger</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ByeBuger是一个能够让你快速实现标题栏以及底部导航栏在滑动时隐藏的库。本文将介绍ByeBuger的使用和实现。&lt;/p&gt;
&lt;p&gt;现在，ByeBuger可以轻易地将&lt;strong&gt;任何view&lt;/strong&gt;在滑动的时候隐藏或者显示。同时支持头部(标题栏)和底部(导航栏
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="wing" scheme="https://yidejia.github.io/tags/wing/"/>
    
      <category term="ByeBurger" scheme="https://yidejia.github.io/tags/ByeBurger/"/>
    
  </entry>
  
  <entry>
    <title>什么是计算机内存？</title>
    <link href="https://yidejia.github.io/2016/11/04/caokun_memory/"/>
    <id>https://yidejia.github.io/2016/11/04/caokun_memory/</id>
    <published>2016-11-04T08:21:55.000Z</published>
    <updated>2016-11-04T08:21:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机存储体系"><a href="#计算机存储体系" class="headerlink" title="计算机存储体系"></a>计算机存储体系</h1><p>先来看这张计算机存储体系结构图。<br><img src="http://upload-images.jianshu.io/upload_images/2764502-3be9f5b75d63ac7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机存储体系.png"></p>
<p>从上图可以看到，越在上面的访问速度越快，但是容量越小，今天要说的就是内存那个环节。</p>
<h1 id="内存是什么"><a href="#内存是什么" class="headerlink" title="内存是什么"></a>内存是什么</h1><ul>
<li><p>内存是可以记录二进制数据一种器件，它是连续的结构，可以随机读写，断电会丢失数据，所有程序必须从磁盘加载到内存中才能运行。</p>
</li>
<li><p>硬件实现简单说一下，二进制数据的每一个bit由一种叫电容器的元件记录，有电子表示1，没电子表示0。可以想象一个4G的内存条，上面有34359738368个这样微小的元件。电容容易丢失电子，所以每64ms必须对内存充电（内存刷新），充电过程中，不允许CPU访问数据，会造成任务延迟。</p>
</li>
</ul>
<h1 id="内存空间管理策略"><a href="#内存空间管理策略" class="headerlink" title="内存空间管理策略"></a>内存空间管理策略</h1><ul>
<li>上面说了内存是一个<strong>连续的线性结构</strong>，一个4G的内存有很多个电容，把他们线性排在一起，那么就有0~34359738367个可以存bit的空位，计算机一般把8个bit合成一个byte存放，那么就有0~4294967295个byte，写成16进制就是 0x0 ~ 0xFFFFFFFF个地址，这个就是内存地址了，每个地址里面可以取出一个字节的数据。</li>
</ul>
<blockquote>
<p>现在有0xFFFFFFFF个地址，人们是怎么利用操作系统去管理和分配这些地址给程序使用的呢？</p>
</blockquote>
<ul>
<li>为了方便说明问题，我把内存地址用10进制表示，转成16进制也是一样的，16进制不太方便人脑计算。我不用4G的内存讲，因为太多了，用0到99的内存空间即可说明问题。我尽量用通俗的语言说明问题，没有很复杂的概念，复杂的概念请翻看《操作系统原理》。</li>
</ul>
<h2 id="虚拟内存地址与实际物理地址"><a href="#虚拟内存地址与实际物理地址" class="headerlink" title="虚拟内存地址与实际物理地址"></a>虚拟内存地址与实际物理地址</h2><ul>
<li><p>在说怎么管理内存之前，先要说一下虚拟内存地址，最开始人们在程序直接使用实际的物理地址，如下图：<br>假设程序a第一次启动被装载在1的位置，第二次启动装载在31的位置。<br>程序a中有段代码 jmp 3，想去执行3那里的目标代码。<br><img src="http://upload-images.jianshu.io/upload_images/2764502-d1816a000ab1d8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="物理地址.png"><br>显然第一次jmp是对的，但第二次操作系统把装在了31的位置，显然目标代码应该是33了，就应该把程序改为jmp 33，否则就出错了。<br><strong>这就是直接使用物理地址的弊端</strong>，每次启动都要重新改代码，或者把所有跳转的地方都+30，很麻烦。所以现代程序都不直接使用物理地址，而是用了虚拟地址，如下图<br><img src="http://upload-images.jianshu.io/upload_images/2764502-6314d7554e7870ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="地址转换.png"><br>使用了虚拟地址后，每个程序就认为自己是从0地址开始的就好了，不管加载到哪个地方，都不用在修改代码，<strong>通过一个段表就可以把虚拟地址转为实际的物理地址</strong>。</p>
</li>
<li><p>在编译器debug中可以看到 0x0012fee8 这些都是虚拟地址，物理地址操作系统不允许直接访问了。<br><img src="http://upload-images.jianshu.io/upload_images/2764502-6ff72ec281f886f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vc6.0.png"></p>
</li>
</ul>
<h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><ul>
<li>最开始人们用段式管理，但是段式管理会产生内存碎片，过程如下图<br><img src="http://upload-images.jianshu.io/upload_images/2764502-eed8719f933779fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存碎片.png"><br>当程序c要加载进内存的时候，程序b前面的空间不够了，只能从b后面分配，于是b前面的空间就不能给c利用，成为了<strong>内存碎片</strong>。</li>
<li>操作系统为了避免这种情况，充分利用内存空间，当内存不够的时候，会采取<strong>内存紧缩</strong>，就是把所有程序都往左边挪动，全部紧紧的排在一起，但是实际中对4GB的内存空间进行紧缩的时候，需要5秒左右的时间，计算机经常卡机5秒你能忍？</li>
<li>程序c分配内存的策略有首先适配法，最佳适配法等方法，考虑到篇幅就不展开讲了，我上面用的就是首先适配法，从左到右首次找到一个合适位置就分配。</li>
</ul>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><ul>
<li>由于段式管理的缺点（外部碎片，内存紧缩），人们后来发明了页式管理，通俗来说，页式管理就是把一定大小的物理空间当做一个页框，整个内存中就有很多个这样的页框，比如0到99的内存空间，按10个字节为一个页框，那么整个内存就分成了10页框，0到9是第0个页框，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2764502-4b7e0ebddaf9e75e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="页框.png"><br>按照页式管理划分空间后，一个程序用一个页框<strong>要么使用页框全部空间，要么不能使用，不能说只用一点点</strong>，如果一个程序用不上那么多空间，也必须拿完，于是段式管理的<strong>外部碎片和内存紧缩</strong>的问题被解决了，提高了内存利用率，但是又产生<strong>内存内部碎片</strong>。</li>
<li>程序的页和页框的大小是一样的，页框大小如何确定？如果页框太大，产生的内部碎片也大，如果页框太小，导致页表变大，查找速度降低。例如4GB的内存，按照4KB分为一页，4GB / 4KB = 1048576项，查找起来自然慢了。</li>
</ul>
<hr>
<p>虚拟地址到物理地址转换过程<br><img src="http://upload-images.jianshu.io/upload_images/2764502-47d5a3076709b55d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="地址转换.png"><br>上图还有个<strong>在不在位</strong>，这个位表示如果程序的页在页框中，那么直接转换，如果不在页框中，那么引发一个<strong>缺页中断</strong>，操作系统去磁盘上把缺失的页加载进内存，然后程序才继续往下运行。这里有个重点，<strong>运行中的程序不一定全部在内存中，也有可能在磁盘上</strong>，在磁盘上的那部分叫做<strong>虚拟内存！</strong>，那究竟程序的哪些页面在内存中，哪些页面在磁盘上，这里就涉及到<strong>页面置换算法</strong></p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>一个程序的部分页面在内存中，部分页面在磁盘上，究竟怎么确定这些页面？<br>我选几个来说</p>
<ul>
<li>先进先出（FIFO）<br>最简单的，最先进来的，就最先淘汰出去。缺点：有些频繁访问的页面也可能淘汰出去。</li>
<li>二次机会（SC）<br>最先进来的页面不一定最先出去，如果这个页面的访问标志是1，那么把它置为0，再给它一次机会，如果页面访问标志0，那么才置换出去。</li>
<li>最近未使用（NRU）<br>每个页面有两个标志位，标记是否访问，是否修改，显然那么没有怎么访问，没有修改的页面会被淘汰出去。</li>
<li>最近最少使用（LRU）<br>这个也很好理解，每个页面有个计数器，访问一次就加1，显然把访问次数很少的那些优先淘汰。</li>
<li>此外还有老化算法，工作集算法，等等，限于篇幅（其实是我写累了）就不详细叙说了，我已经写了个实验代码，在<a href="https://github.com/hehe520/Data-structure-and-algorithm/tree/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95" target="_blank" rel="external">这里</a>可以看到。</li>
</ul>
<h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><p>最后是段页式管理，结合了段式页式的优缺点，把程序先分段，在每个段内再分页，来管理内存，windows操作系统就是用这个方法管理的，当然实际中更加复杂，绝对没有我说的这么简单，我只是通俗的说清原理，详情请看《操作系统原理》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机存储体系&quot;&gt;&lt;a href=&quot;#计算机存储体系&quot; class=&quot;headerlink&quot; title=&quot;计算机存储体系&quot;&gt;&lt;/a&gt;计算机存储体系&lt;/h1&gt;&lt;p&gt;先来看这张计算机存储体系结构图。&lt;br&gt;&lt;img src=&quot;http://upload-images
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="曹堃" scheme="https://yidejia.github.io/tags/%E6%9B%B9%E5%A0%83/"/>
    
      <category term="内存" scheme="https://yidejia.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>iOS - 仿UC浏览器首页下拉动画及实现分析</title>
    <link href="https://yidejia.github.io/2016/11/04/caokun_UC_animation/"/>
    <id>https://yidejia.github.io/2016/11/04/caokun_UC_animation/</id>
    <published>2016-11-04T08:12:55.000Z</published>
    <updated>2016-11-04T08:58:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h1><p><img src="http://upload-images.jianshu.io/upload_images/2764502-f79c05d1173662a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p>
<p>经常用UC看到首页有这么一个动画，就仿造写了一下。</p>
<h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><h3 id="1-画曲线的动画"><a href="#1-画曲线的动画" class="headerlink" title="1.画曲线的动画"></a>1.画曲线的动画</h3><p>这个一眼看去就想到用贝塞尔曲线画，来看贝塞尔曲线方法，给出两个定点，和一个控制点就可以画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextAddQuadCurveToPoint(context, 控制点x, 控制点y, 目标点x, 目标点y);</div></pre></td></tr></table></figure></p>
<p>于是按照下图，两个黄色的点是定点，绿色的是控制点，于是画出了这样的图。<br><img src="http://upload-images.jianshu.io/upload_images/2764502-6c714da4d784ba32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>
<p>看左边的图，中间有大片空白，看起来很浪费屏幕空间，用户体验不太好，于是想着怎么让贝塞尔曲线过某个定点，比如让曲线过绿色的定点，而不是把控制点设在绿色的位置。</p>
<p>重诉一下，现有的方法是给出两个定点和一个控制点，能画一条曲线。<br>现在是要，<strong>已知两个定点，和过另外一个定点D，画一条曲线。</strong></p>
<p>我现在想让这条曲线过绿色的点，就像下图那样，求控制点坐标是多少？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2764502-05b3633524b49863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3"></p>
<p>看下图，求出控制点坐标的过程<br><img src="http://upload-images.jianshu.io/upload_images/2764502-33f2c618ab9c3e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4"></p>
<p>由上图就得出了控制点的坐标，然后就可以画出“图3”的样子了，实际中我觉得图3贴太紧了，也不美观，于是 yc 乘了个0.6的系数，即 yc = 0.6 * yc，就看起来比较顺眼了。</p>
<h3 id="2-页面结构"><a href="#2-页面结构" class="headerlink" title="2.页面结构"></a>2.页面结构</h3><p>页面结构大概是这样，底下的 tableView 铺满整个 view，然后蓝色的headerView 加在 tableView 的上面，不是加 tableView.tableHeaderView 上面哦，至于为什么你加加看就知道了。会跟着 tableview 动</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2764502-dd0d035e4b25f762.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5"></p>
<h3 id="3-不规则事件点击，事件穿透"><a href="#3-不规则事件点击，事件穿透" class="headerlink" title="3.不规则事件点击，事件穿透"></a>3.不规则事件点击，事件穿透</h3><p>headerView 上有一个头像，是可以点击的，其他地方的点击事件要传给底下的 tableView 也叫事件穿透，通过修改 hitTest 可以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;</div></pre></td></tr></table></figure></p>
<p>hitTest 主要用来做事件分发的，可以实现不规则点击，它在整个 view 结构上是递归的，深度优先的，今天不讲算法，因为 hitTest 太厉害，不规则点击用 pointInside 函数就够了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</div></pre></td></tr></table></figure></p>
<p>这个函数会被 hitTest 调用，返回 false 表示点击的不是自己，返回 true 表示点击的是自己。<br>那么，我只要判断点击的 point 在不在头像的那个圆圈里面就可以了，就是判断点在不在圆内，高中讲过了，point 到圆心的距离小于半径就表示在了，那么返回 true 就行。具体的还是看代码吧。<br>如果有多个控件，需要自己确定每个控件的点击区域。</p>
<p>最后还是上个代码 <a href="https://github.com/hehe520/PullAnimation" target="_blank" rel="external">下载地址</a>，下载慢慢看吧。</p>
<h3 id="4-后期改进"><a href="#4-后期改进" class="headerlink" title="4.后期改进"></a>4.后期改进</h3><p>写完这个博客突然想到一个还要改的地方，就是当用户手指松开的时候，scrollViewWillEndDragging，这个方法内判断一下，contentOffset.y 值，如果超过多少值，那么自动回调一个 block，可实现下拉刷新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动画效果&quot;&gt;&lt;a href=&quot;#动画效果&quot; class=&quot;headerlink&quot; title=&quot;动画效果&quot;&gt;&lt;/a&gt;动画效果&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/276450
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="曹堃" scheme="https://yidejia.github.io/tags/%E6%9B%B9%E5%A0%83/"/>
    
      <category term="动画" scheme="https://yidejia.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="iOS" scheme="https://yidejia.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>通俗讲解股票类app - TCP网络通信层设计</title>
    <link href="https://yidejia.github.io/2016/11/04/caokun_socket/"/>
    <id>https://yidejia.github.io/2016/11/04/caokun_socket/</id>
    <published>2016-11-04T07:12:55.000Z</published>
    <updated>2016-11-04T07:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>要做的产品 — 炒股app</p>
<ul>
<li><strong>数据量大</strong>：5000多支股票，每支股票有分时，分笔数据，画一条k线，可能要500条分时数据，甚至更多。</li>
<li><strong>实时性</strong>：股价每分每秒都在变化，一分钟产生很多条数据，用户要看到最新的信息，真的是一秒钟上下几十万啊。</li>
<li><strong>服务器主动推</strong>：股票预警等等一些重要消息，需要服务器实时推送，保证客户端100%收到，收不到可能造成客户资金损失。</li>
</ul>
<p>由于这些场景因素，股票的数据不能通过HTTP协议来传输了，只能走TCP协议了，当然一些个人信息什么的还是走HTTP的。</p>
<h1 id="技术细节实现"><a href="#技术细节实现" class="headerlink" title="技术细节实现"></a>技术细节实现</h1><p>1.<strong>数据量比较大</strong>，一次请求可能返回几百条数据到移动端，对数据要进行压缩，这里采用了 google 的 <strong>Protocol Buffer</strong> 数据传输格式，因为它对象序列化速度快，压缩率高 (ps: http 一般用 json, xml)。</p>
<p>2.<strong>实时性与主动推</strong>：服务器与客户端之间维护一条 tcp 长连接，避免每次3次握手，4次挥手，和产生一堆 time_wait 状态的 socket 占用资源。走tcp协议需要自己维护一些状态<br><strong>掉线重连</strong>，移动端网络情况复杂，有3G，4G，wifi，socket 经常断开，它断了要自动连上，并且还要<strong>对应用层透明！</strong>不能让应用层感知到！连上后数据接着之前断开的地方发送，不能有影响。<br><strong>自动登录</strong>，这个是掉线重连后要做的一个操作，不登录拿不到股票数据。登录后接着做一个消息同步，看看有没有新消息。</p>
<p>3.<strong>客户端100%收到</strong>（可靠性）：除了 tcp 超时重传和3次ack回应保证了可靠传输之外，我们在app里也实现了一套<strong>应用层的ack机制</strong>，服务器保存了一组消息，每个消息有个seq号，一个消息推给客户端后，客户端拿到消息的seq，要发ack请求回应服务器这个消息，然后下次服务器才不会推给你，不然的话，下次服务器还是会推给你的。掉线重连，重登录后会同步一次你订阅过的消息，把上次没收到的，或者丢包的消息再同步过来。</p>
<p>4.<strong>客户端的负载均衡</strong>，这个一般在服务器做，但后台那边说防止ip封锁，还有某些服务器不能在全国访问到，所以把负载均衡放在客户端做了，app启动拉取服务器列表，然后多线程并发发送测速包，得到每个服务器延迟和负载，然后选个最优的服务器连上即可，延迟可以理解为路有多长，负载可以理解为路上拥堵情况，显然最短的路不一定是最快的，它可能很堵。</p>
<p>根据以上因素，我设计了一套TCP层的网络请求逻辑，应用层只管发请求就好了，我只告诉你有没有结果，上面的细节全部屏蔽在底层，<strong>对应用层透明！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 应用层发一个 tcp 请求的代码例子，支持多线程循环发：</div><div class="line">[[TCPAPI instance] requestStockInfoWithcompletion:^(id response, NSString *error) &#123;</div><div class="line">    if (error == nil) &#123;</div><div class="line">        NSLog(@&quot;成功：%@&quot;, (NSArray *)response);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;失败：%@&quot;, error);</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>测试：我用一条线程以每隔 0.1 秒的速度循环发送请求，然后模拟断网，网络差，被服务器踢下线等等情况，程序工作正常，一旦有网络，数据就会成功返回。</p>
</blockquote>
<p>整个app网络层的请求逻辑图：<br>我有个 tcp 请求同步队列接收应用层来的请求，有句话叫做”we cannot send directly, so queue it”，然后一个请求走完图中的逻辑，下一个请求接着走，每一个请求有一个定时器，超时就回调一个失败结果给应用层，有张映射表保存请求和回调之间的映射。<br>然后还一个socket发送队列，真正去发送数据的队列，socket接收队列就不用说了吧，把接收到的数据通过pb协议反序列化得到pb对象的，这里有个 tcp 分片机制导致的 <strong>tcp 粘包问题</strong>，就是 socket 返回一段二进制数据不一定刚好就是一个对象的全部数据，可能少可能多，要自己判断，拆包的时候注意下就好了。<br>得到 pb 对象，把这个结果回调给应用层，整个流程就走完了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2764502-7b0dff3e234ee701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp请求逻辑.png"></p>
<p>图片可能太大，可以到<a href="https://github.com/hehe520/AsyncSocket" target="_blank" rel="external">这里下载</a>来看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;要做的产品 — 炒股app&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据量大&lt;/strong&gt;：5000多支股票，每支股票有分时，分笔数据
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="曹堃" scheme="https://yidejia.github.io/tags/%E6%9B%B9%E5%A0%83/"/>
    
      <category term="socket" scheme="https://yidejia.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>iOS - 接入WebSocket记录 + 一些个人经验</title>
    <link href="https://yidejia.github.io/2016/11/04/caokun_websocket/"/>
    <id>https://yidejia.github.io/2016/11/04/caokun_websocket/</id>
    <published>2016-11-04T06:12:55.000Z</published>
    <updated>2016-11-04T08:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闲扯"><a href="#闲扯" class="headerlink" title="闲扯"></a>闲扯</h1><p>WebSocket 以前没用过，之前写过一篇博客是基于原生socket的（<a href="http://www.jianshu.com/p/edb50afa250e" target="_blank" rel="external">查看</a>）比较复杂，慎入。今天另外一个APP需要接websocket了，然后便找到了facebook的 <a href="https://github.com/facebook/SocketRocket" target="_blank" rel="external">SocketRocket</a> 框架，然后用了一天时间接上了，完成了掉线自动重连，自动重登录，心跳等等功能，用法比原生socket简单（原生socket基于TCP/UDP协议）。</p>
<h1 id="为什么用-WebSocket"><a href="#为什么用-WebSocket" class="headerlink" title="为什么用 WebSocket"></a>为什么用 WebSocket</h1><p>因为APP里面有个聊天功能，需要服务器主动推数据到APP。HTTP 通信方式只能由客户端主动拉取，服务器不能主动推给客户端，如果有实时的消息，要立刻通知客户端就麻烦了，要么客户端每隔几秒钟发一次请求，看看有没有新数据，这种方式想想都知道耗流量电量。还一种方式就是走TCP/UDP协议服务器主动推给你，这种方式省流量。还有就是用websocket，websocket是h5里面的东西，h5我不太会，反正它比原生socket用法简单。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>用 SocketRocket 框架，记住几个代理方法就好了，很简单。</p>
<h2 id="1-创建和设置代理对象"><a href="#1-创建和设置代理对象" class="headerlink" title="1.创建和设置代理对象"></a>1.创建和设置代理对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SRWebSocket *socket = [[SRWebSocket alloc] initWithURLRequest:</div><div class="line">[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://ip地址:端口&quot;]];</div><div class="line"></div><div class="line">socket.delegate = self;    // 实现这个 SRWebSocketDelegate 协议啊</div><div class="line"></div><div class="line">[socket open];    // open 就是直接连接了</div></pre></td></tr></table></figure>
<h2 id="2-连接成功会调用这个代理方法"><a href="#2-连接成功会调用这个代理方法" class="headerlink" title="2.连接成功会调用这个代理方法"></a>2.连接成功会调用这个代理方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)webSocketDidOpen:(SRWebSocket *)webSocket &#123;</div><div class="line">    NSLog(@&quot;连接成功，可以立刻登录你公司后台的服务器了，还有开启心跳&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-连接失败会调用这个方法，看-NSLog-里面的东西"><a href="#3-连接失败会调用这个方法，看-NSLog-里面的东西" class="headerlink" title="3.连接失败会调用这个方法，看 NSLog 里面的东西"></a>3.连接失败会调用这个方法，看 NSLog 里面的东西</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didFailWithError:(NSError *)error &#123;</div><div class="line">    NSLog(@&quot;连接失败，这里可以实现掉线自动重连，要注意以下几点&quot;);</div><div class="line">    NSLog(@&quot;1.判断当前网络环境，如果断网了就不要连了，等待网络到来，在发起重连&quot;);</div><div class="line">NSLog(@&quot;2.判断调用层是否需要连接，例如用户都没在聊天界面，连接上去浪费流量&quot;);</div><div class="line">NSLog(@&quot;3.连接次数限制，如果连接失败了，重试10次左右就可以了，不然就死循环了。</div><div class="line">或者每隔1，2，4，8，10，10秒重连...f(x) = f(x-1) * 2, (x&lt;5)  f(x)=10, (x&gt;=5)&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-连接关闭调用这个方法，注意连接关闭不是连接断开，关闭是-socket-close-客户端主动关闭，断开可能是断网了，被动断开的。"><a href="#4-连接关闭调用这个方法，注意连接关闭不是连接断开，关闭是-socket-close-客户端主动关闭，断开可能是断网了，被动断开的。" class="headerlink" title="4.连接关闭调用这个方法，注意连接关闭不是连接断开，关闭是 [socket close] 客户端主动关闭，断开可能是断网了，被动断开的。"></a>4.连接关闭调用这个方法，注意连接关闭不是连接断开，关闭是 [socket close] 客户端主动关闭，断开可能是断网了，被动断开的。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(NSInteger)code reason:(NSString *)reason wasClean:(BOOL)wasClean &#123;</div><div class="line">    NSLog(@&quot;连接断开，清空socket对象，清空该清空的东西，还有关闭心跳！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-收到服务器发来的数据会调用这个方法"><a href="#5-收到服务器发来的数据会调用这个方法" class="headerlink" title="5.收到服务器发来的数据会调用这个方法"></a>5.收到服务器发来的数据会调用这个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(id)message  &#123;</div><div class="line">NSLog(@&quot;收到数据了，注意 message 是 id 类型的，学过C语言的都知道，id 是 (void *)  </div><div class="line">void* 就厉害了，二进制数据都可以指着，不详细解释 void* 了&quot;);</div><div class="line">NSLog(@&quot;我这后台约定的 message 是 json 格式数据</div><div class="line">收到数据，就按格式解析吧，然后把数据发给调用层&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-向服务器发送数据"><a href="#6-向服务器发送数据" class="headerlink" title="6.向服务器发送数据"></a>6.向服务器发送数据</h2><p>发送的时候可能断网，可能socket还在连接，要判断一些情况，写在下面了<br>发送逻辑是，我有一个 socketQueue 的<strong>串行</strong>队列，发送请求会加到这个队列里，然后一个一个发出去，如果掉线了，重连连上后继续发送，<strong>对调用层透明，调用层不需要知道网络断开了</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)sendData:(id)data &#123;</div><div class="line">    WEAKSELF(ws);</div><div class="line">    dispatch_async(self.socketQueue, ^&#123;</div><div class="line">        if (ws.socket != nil) &#123;</div><div class="line">// 只有 SR_OPEN 开启状态才能调 send 方法啊，不然要崩</div><div class="line">            if (ws.socket.readyState == SR_OPEN) &#123;</div><div class="line">                [ws.socket send:data];    // 发送数据</div><div class="line"></div><div class="line">            &#125; else if (ws.socket.readyState == SR_CONNECTING) &#123;</div><div class="line">                NSLog(@&quot;正在连接中，重连后其他方法会去自动同步数据&quot;);</div><div class="line">// 每隔2秒检测一次 socket.readyState 状态，检测 10 次左右</div><div class="line">// 只要有一次状态是 SR_OPEN 的就调用 [ws.socket send:data] 发送数据</div><div class="line">// 如果 10 次都还是没连上的，那这个发送请求就丢失了，这种情况是服务器的问题了，小概率的</div><div class="line">// 代码有点长，我就写个逻辑在这里好了</div><div class="line"></div><div class="line">            &#125; else if (ws.socket.readyState == SR_CLOSING || ws.socket.readyState == SR_CLOSED) &#123;</div><div class="line">// websocket 断开了，调用 reConnect 方法重连</div><div class="line">                [ws reConnect:^&#123;</div><div class="line">                    NSLog(@&quot;重连成功，继续发送刚刚的数据&quot;);</div><div class="line">[ws.socket send:data];</div><div class="line">                &#125;];</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            NSLog(@&quot;没网络，发送失败，一旦断网 socket 会被我设置 nil 的&quot;);</div><div class="line">NSLog(@&quot;其实最好是发送前判断一下网络状态比较好，我写的有点晦涩，socket==nil来表示断网&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7-心跳机制"><a href="#7-心跳机制" class="headerlink" title="7.心跳机制"></a>7.心跳机制</h2><p>心跳机制就不难了，开个定时器，问下后台要每隔多少秒发送一次心跳请求就好了。然后注意，断网了或者socket断开的时候把心跳关一下，省资源，不然都断网了，还在循环发心跳，浪费CPU和电量。</p>
<p>终于接完websocket了，下班回家压压惊。我第一次用，其实不难，就是考虑的情况比较多，整个逻辑有点多，主要代码就是上面那些了，其他不重要的代码我就不复制粘贴上来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h1&gt;&lt;p&gt;WebSocket 以前没用过，之前写过一篇博客是基于原生socket的（&lt;a href=&quot;http://www.jianshu.com/p
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="曹堃" scheme="https://yidejia.github.io/tags/%E6%9B%B9%E5%A0%83/"/>
    
      <category term="iOS" scheme="https://yidejia.github.io/tags/iOS/"/>
    
      <category term="websocket" scheme="https://yidejia.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub 搭建属于个人或团队的技术博客</title>
    <link href="https://yidejia.github.io/2016/11/02/Hexo%20+%20GitHub%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E4%B8%AA%E4%BA%BA%E6%88%96%E5%9B%A2%E9%98%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    <id>https://yidejia.github.io/2016/11/02/Hexo + GitHub 搭建属于个人或团队的技术博客/</id>
    <published>2016-11-02T09:23:55.000Z</published>
    <updated>2016-11-29T01:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多个人或团队都有写博客的习惯，有的会选择将博客发表到如 CSDN、简书等比较受欢迎的地方，毕竟那里聚集了从菜鸟到大神的各类人才，来学习的和来吐槽的都有。本人就是喜欢热闹点的地方😬。不过今天不是介绍怎样将博文发表到这些地方，而是介绍如何使用 <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> + <a href="https://github.com" target="_blank" rel="external">GitHub</a> 来搭建一个属于个人或团队的技术博客（从某种程度上也能提升逼格）。当然写博客最重要的还是抱着一种技术沉淀和积累的心态，将自己的所见、所闻、所感分享给大家。对于团队来说，也在一定程度上向外界传递当前团队的技术研发方向，招纳贤士，吸引人才嘛。</p>
<p>虽然这类文章现在满大街都是，但我觉得还是有必要将这两天的搭建过程给记下来，这其中包含了一些细节需要注意的。以下操作都是基于 Mac 系统，其他平台的请另行查阅。同时建议即将动手实战的朋友先通读本文，有些细节可能需要你提前注意的。最后，请自配翻墙工具。</p>
<h3 id="一、准备环境"><a href="#一、准备环境" class="headerlink" title="一、准备环境"></a>一、准备环境</h3><p>Hexo 的安装需要依赖 Node.js，而对博客的管理我们选择 Git，所以我们要提前准备这两个环境。</p>
<h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><p>使用 brew 来安装 Git：</p>
<p> <code>brew install git</code></p>
<h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>首先我们需要通过 cURL 来安装 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>：</p>
<p><code>$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</code></p>
<p>安装完成后，重新启动终端然后执行如下命令来安装 Node.js：</p>
<p><code>nvm install stable</code></p>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>经过上述步骤后，最后使用 npm 来安装 Hexo：</p>
<p><code>npm install -g hexo-cli</code>。</p>
<h3 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h3><p>既然我们使用 Hexo 来搭建博客，那势必要熟悉一下 Hexo 的几个常用语法：</p>
<p>1、首先选择一个目录，如/Users/zxq/Document/Blog 作为我们存储博客文件的目录，命令行切换到该目录下，然后执行：</p>
<p><code>hexo init</code></p>
<p>2、初始化完成后，我们还需要执行下面命令来安装一些依赖：</p>
<p><code>npm install</code></p>
<p>现在你的目录结构看起来应该是这样的：</p>
<p><img src="https://cloud.githubusercontent.com/assets/7321351/19918231/81b8d62a-a104-11e6-8720-318784661abb.png" alt=""></p>
<p>因为我后面还装了一些插件，所以可能会多出 node_modules 这个目录，db.json 就是一个数据文件，部署运行后会自动生成。</p>
<p>到这里，博客的基础框架就搭建完成了，接下来我们就来部署一下，看看最终的显示效果。<strong>如果没特别提示的，下面的命令都在本地博客的根目录下操作</strong>。依次执行: <code>hexo clean</code>、<code>hexo generate</code>、<code>hexo server</code>。当运行 <code>hexo server</code> 后，命令行中会提示你访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>，打开浏览器看是否能正常访问。如果失败则需要在命令行窗口中查看失败日志。</p>
<p>简单说一下上面三个命令具体是执行哪些任务：</p>
<ol>
<li><strong>hexo clean:</strong> 清除 hexo 生成的静态文件，由于 hexo 是一个博客框架，会将你编写的 Markdown 文件转换成相应的 HTML 文件，执行这个命令就可以删除系统为你生成的这些静态文件。</li>
<li><strong>hexo generate:</strong> 通过上面的命令你也许能猜到这个命令的用意了，就是帮你生成静态文件的。</li>
<li><strong>hexo server:</strong> 本地部署，这样你就能直接在浏览器上通过 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 访问你的博客了。</li>
</ol>
<p>其实上面命令还有对应的快捷方式，这个留给各位朋友自己摸索了。</p>
<h3 id="三、编写博文"><a href="#三、编写博文" class="headerlink" title="三、编写博文"></a>三、编写博文</h3><p>博客搭建完后，接下来就要靠各位日后的辛勤耕耘和乐于分享了。<br>我们可以直接通过 <code>hexo new Hello_World</code> 命令来创建博文，这种方式默认会将博文放置到博客根目录下的 <code>source/_post</code> 目录中。你也可以选择到该目录下创建 Markdown 文件。当编写好博文后，通过上面描述的三条命令 <strong>clean</strong>，<strong>generate</strong>，<strong>server</strong> 重新部署一下就可以了。</p>
<p>当然，编写博文的方式还远远不止这些， 详情请查看 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo 官方文档</a>。</p>
<h3 id="四、GitHub-远程部署博客"><a href="#四、GitHub-远程部署博客" class="headerlink" title="四、GitHub 远程部署博客"></a>四、GitHub 远程部署博客</h3><p>完成上面三个步骤后，你现在的博客仅仅是部署在你本地电脑上，只允许同一局域网进行访问，当然如果你有自己的服务器那就另当别论了。下面将介绍如何将你的博客部署到全球最大的程序员交友网站 <a href="https://github.com" target="_blank" rel="external">GitHub</a>。在这里我先申明一下，你既然都看到了这篇文章，那至少你对 GitHub 有所了解了，起码也得有个账号吧。</p>
<p>接下来我们登录 GitHub，新建一个仓库。注意，这个仓库名称必须是：GitHub 的账户昵称 + “.github.io”，如</p>
<p><img src="https://cloud.githubusercontent.com/assets/7321351/19919154/ce5cfa54-a10b-11e6-8dc7-414ede4ae44b.png" alt=""></p>
<p>因为我已经创建过了，所以会提示仓库已存在。你要注意的就是这个仓库名称格式，这个仓库名称格式，这个仓库名称格式，重要事情说三遍。只有这种格式的仓库 GitHub 才能识别。</p>
<p>这里要唠叨两句，很重要的，不要走神。在 GitHub 上每创建一个仓库，那么该仓库默认会指定 master 分支作为其主要分支。博客仓库（xxx.github.io）也是一样的，GitHub 会默认部署 master 分支上的静态文件（前面说过静态文件是 hexo 将博客源文件转化后的产物）。你若不小删除了这些静态文件我们还可以通过源文件再生成，但如果你不小心删除了博客源文件，那可能就麻烦了。所以我们要借助 Git 来管理我们整个博客的源文件了。可能有些人会想再创建一个新的仓库来管理这些源文件，当然这样也没有错，但还有另一种方式，那就是在博客仓库中再创建一个分支，如下图：</p>
<p><img src="http://7xqitw.com1.z0.glb.clouddn.com/blog-resgit_hub_new_branch.png" alt=""></p>
<p><code>注意：hexo 生成的静态文件和博客源文件最好不要混在一起管理，这也是为什么需要两个分支的原因，一个管理静态文件，一个管理博客源文件。</code></p>
<p>因为我们大多数时间是花在写博客上，所以选择用 hexo 分支来管理我们的博客源文件，而 master 分支用于管理静态文件。在 hexo 分支上的操作跟普通操作 git 一样，至于怎么更新 master 分支上的静态文件后面会揭晓。</p>
<p>不过现在博客仓库的默认分支还是 master，这里我们要将 hexo 修改为默认分支，方便Git 今后操作源文件。操作如下：</p>
<p><img src="https://cloud.githubusercontent.com/assets/7321351/19921082/454918ae-a117-11e6-8163-47707a23d4f4.png" alt=""></p>
<p>当执行完上述流程后，打开本地博客根目录下的 <strong>_config.xml</strong> 配置文件，索引 <em>Deployment</em> 然后替换为下面的信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: https://github.com/xxx/xxx.github.io (你的博客仓库地址）</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>保存后接着执行 <code>npm install hexo-deployer-git --save</code>，只有执行该命令我们才能将待会生成的静态文件推送到远程仓库中。</p>
<p>好了，该准备的也准备得差不多了。提醒一下，推送静态文件到远程 master 分支不再是什么 git push，而是这一系列的命令：<strong>hexo clean，hexo generate，hexo deploy</strong>。细心的朋友可能发现最后一个命令不再是上面提到的 <strong>hexo server</strong>，而是<strong>hexo deploy</strong>，相当于将本地的这些静态文件部署推送到远程的 master 分支上。这一切的前提是上面配置文件中的仓库地址要填写正确。</p>
<p>现在就可以到 GitHub 网站上查看博客仓库的 master 分支上是否有那些静态文件，诸如 html，js 和 css 等等。如果正常的话，那么过一会你就能通过 <a href="https://xxx.github.io（比如" target="_blank" rel="external">https://xxx.github.io（比如</a> <a href="https://anenn.github.io" target="_blank" rel="external">https://anenn.github.io</a>） 这个地址直接访问你的博客，因为 GitHub 已经为你完成部署工作了。</p>
<h3 id="四、博客源文件管理"><a href="#四、博客源文件管理" class="headerlink" title="四、博客源文件管理"></a>四、博客源文件管理</h3><p>完成上述流程后，那接下来的也就小菜一碟了。我们要用 Git 来管理我们的文件，基本流程就是：</p>
<ul>
<li>命令行切换到本地博客根目录下，执行 git init，表明我们要用 Git 来管理该目录下的所有文件；</li>
<li>然后将本地仓库跟远程仓库进行绑定，执行 git remote add origin xxx(远程仓库地址，如 <a href="https://github.com/anenn/anenn.github.io)；" target="_blank" rel="external">https://github.com/anenn/anenn.github.io)；</a></li>
<li>切换分支到 hexo，执行 git checkout -b hexo；</li>
<li>将源文件先添加到本地仓库中，在此之前我建议先执行一下 hexo clean，将系统为我们生成的静态文件删除，因为它不属于我们的博客源文件，然后再执行 git add . | git commit -m “xxx”；</li>
<li>最后就是同步了，执行 git pull | git push</li>
</ul>
<p>记住，今后一切一切的操作都在 hexo 分支上执行，不要再跑去 master 分支上瞎闹，搞不好会搞挂博客的。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>上面流程下来不出意外的话应该是可以正常运行的，如果有什么问题的请留言反馈。最后想对搭团队博客的朋友说，如果团队成员有写博客的习惯，若让他们每个人在自己电脑上都搞这一套，不用想，肯定不会怎么受欢迎的。所以，可以接受的方式就是让他们 clone 下团队博客的源代码，然后让他们切换到 hexo 分支上去编写博文，最后同步上去再由自动化脚本去执行部署操作。对于他们来说，整个部署流程透明化，他们仅需关心的就是如何写好每一篇博文。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ol>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo 官方文档</a></li>
<li><a href="http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/" target="_blank" rel="external">Hexo利用Github分支在不同电脑上写博客</a></li>
<li><a href="http://www.rvclient.com/2016/05/21/hexo-everywhere/" target="_blank" rel="external">在不同的电脑维护Hexo和写作</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在很多个人或团队都有写博客的习惯，有的会选择将博客发表到如 CSDN、简书等比较受欢迎的地方，毕竟那里聚集了从菜鸟到大神的各类人才，来学习的和来吐槽的都有。本人就是喜欢热闹点的地方😬。不过今天不是介绍怎样将博文发表到这些地方，而是介绍如何使用 &lt;a href=&quot;http
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://yidejia.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://yidejia.github.io/tags/GitHub/"/>
    
      <category term="Blog 博客" scheme="https://yidejia.github.io/tags/Blog-%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="张晓钦" scheme="https://yidejia.github.io/tags/%E5%BC%A0%E6%99%93%E9%92%A6/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins+GitLab+Android+iOS+Sonar搭建持续集成环境</title>
    <link href="https://yidejia.github.io/2016/11/02/Jenkins-%E6%90%AD%E5%BB%BA/"/>
    <id>https://yidejia.github.io/2016/11/02/Jenkins-搭建/</id>
    <published>2016-11-02T06:12:55.000Z</published>
    <updated>2016-11-29T01:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2083649-6bdfa1e51a834687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins持续集成系统"></p>
<p>持续集成是敏捷开发的重要一环,它具备以下优点:</p>
<blockquote>
<p>减少并降低软件开发中的风险</p>
<p>将重复性工作自动化，让开发人员更专注于代码</p>
<p>在任何时间、任何地点生成可部署的软件</p>
</blockquote>
<p>随着人员以及项目的增加,以上这些就变得尤为重要.所以我们也在恰当的时机把它引入进来.</p>
<p>而市面上持续集成系统琳琅满目,有Jenkins,Travis,Circleci,Bitrise,Flow.ci 我们该如何选择,那就参考大数据,朝内还是用百度指数,目前只收录Jenkins和Travis.</p>
<blockquote>
<p>Jenkins:蓝色      Travis:绿色</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-669cc44ae2cb7f3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins和Travis百度搜索趋势"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-36cdd1235c8b8416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jenkins和Travis百度搜索人群画像"></p>
<p>Jenkins更为成熟，它是框架式的，大部分功能通过插件的方式来实现，可扩展性非常高.</p>
<p>废话少说,直接来撸一撸!</p>
<p>下载<a href="http://www.androiddevtools.cn/" title="Android SDK" target="_blank" rel="external">Android SDK</a></p>
<p>下载<a href="https://jenkins.io/" title="Jenkins 安装" target="_blank" rel="external">Jenkins 安装</a></p>
<p>通过HomreBrew安装启动和停止jenkins服务:</p>
<blockquote>
<p>brew install jenkins</p>
<p>brew tap homebrew/services</p>
<p>Start Jenkins: sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</p>
<p>Stop Jenkins: sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</p>
<p>开机启动 Run at boot:  /Library/LaunchDaemons 可以在这里修改jenkins相关信息</p>
<p>Run at login: /Users/Lavare/Library/LaunchAgents</p>
</blockquote>
<p> 通过pkg文件安装的可以通过 java命令启动:</p>
<blockquote>
<p>java -jar /Applications/Jenkins/jenkins.war</p>
</blockquote>
<h1 id="Jenkins安装配置各种插件"><a href="#Jenkins安装配置各种插件" class="headerlink" title="Jenkins安装配置各种插件:"></a>Jenkins安装配置各种插件:</h1><p><strong>Git  —- GitLab —- Gitlab Authentication plugin</strong>  (Git授权插件)</p>
<p> <strong>Environment Injector Plugin</strong> (环境变量注入,目前用于获取gitLog,并传递给Fir.im上传信息)</p>
<p><strong>Email Extension</strong>  (邮件扩展插件,打包完成后邮件通知各人员)</p>
<p>  <strong>Fir Plugin</strong>  (Fir.im上传插件,apk/ipa 分发渠道)</p>
<p> <strong>Bearychat Plugin</strong> (上传到Bearychat插件,同于通知)</p>
<p><strong>Gradle Plugin</strong>   (Android 构建插件)</p>
<p> <strong>Xcode integration</strong>  (iOS构建插件)</p>
<p><strong>Keychains and Provisioning Profiles Management</strong>  (iOS证书配置插件)</p>
<p><strong>Sonar:</strong>代码质量管理平台,也是通过安装各种插件来扩展代码检测功能</p>
<blockquote>
<p>1.糟糕的复杂度分布</p>
<p>2.重复</p>
<p>3.缺乏单元测试</p>
<p>4.没有代码标准</p>
<p>5.没有足够的或者过多的注释</p>
<p>6.潜在的bug</p>
<p>7.糟糕的设计</p>
</blockquote>
<p>在系统管理界面配置-&gt;系统设置</p>
<p>GitLab配置,使用Api Token验证</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-6dcfef59a82a3822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置GitLab的Token"></p>
<p>Bearychat配置,方便后期构建成功后通知到相应群组</p>
<blockquote>
<ul>
<li><p>Team Subdomain: 在 <a href="https://ydj.bearychat.com" target="_blank" rel="external">https://ydj.bearychat.com</a> 中，如yjd便是团队的 subdomain</p>
</li>
<li><p>Integration Token: 在 BearyChat 中的 Jenkins 机器人的 hook 地址中， 最后的部分便是 token。</p>
</li>
<li><p>Channel: 讨论组名称，如果指定的话，可以将 Jenkins 通知推送到该讨论组</p>
</li>
<li><p>Build Server URL: 团队的 Jenkins 服务器所在的地址，用于构建 Jenkins 通知中的链接等信息</p>
</li>
<li><p>Test Connection: 在填写上面的相关信息后，可以测试下是否配置成功</p>
</li>
</ul>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-fabc61f59e3309fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bearychat配置"></p>
<p>配置Sonar代码质量管理服务器</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-ffd0ddbe56747fb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sonar服务器配置"></p>
<p>在Global Tool Config配置jdk,git</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-c3d6c9a0897b1b5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jdk以及Git安装"></p>
<h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><p>新建项目,使用自有构建模式<br><img src="http://upload-images.jianshu.io/upload_images/2083649-59ba19827f5435b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目类型选择"></p>
<p>指定工作目录,和保持构建的天数,及最大个数,自定义目录</p>
<blockquote>
<p>注意: 如果使用自定义工作空间,要考虑目录对当前是否有写入的权限,<br><img src="http://upload-images.jianshu.io/upload_images/2083649-99d62727fde70207.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目配置"></p>
</blockquote>
<p>源码管理使用http地址,也可以使用ssh要配key较麻烦<br><img src="http://upload-images.jianshu.io/upload_images/2083649-8b1a1e0e4bc04cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitLab项目配置"></p>
<p>构建触发器,配置gitlab的webhook,有push变化则自动构建打包,指定对某一个分支有效:<br><img src="http://upload-images.jianshu.io/upload_images/2083649-4ffba65d72bad09e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitLab触发配置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-b6b873d4b8a8bb68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitLab的Webhook配置"></p>
<p>周期性触发器:</p>
<blockquote>
<p>Build periodically指周期性构建（Provides a cron-like feature to periodically execute this project.）</p>
<p>Poll SCM指周期性扫描远程git repository，当有变化时进行构建（Configure Jenkins to poll changes in SCM.）</p>
</blockquote>
<p>日期定义</p>
<blockquote>
<p>Cron表达式字符串的格式为“分 小时 日 月 星期 年”，其中“年”是可选的，其余5个字段是必须的。</p>
<p>区别（1）没有秒 （2）星期的取值范围是0-6（SUN-SAT）</p>
<p>字段取值范围通配符分0-59<em> / , -时0-59</em> / , -日1-31<em> / , - ? L W月1-12 or JAN-DEC</em> / , -星期0-6 or SUN-SAT<em> / , - ? L #年1970–2099</em> / , -</p>
<p>例子:</p>
<p><em>/5 </em> <em> </em> *  // 每5分钟</p>
<p>H/5 <em> </em> <em> </em>    // 每5分钟 推荐</p>
<p>5 <em> </em> <em> </em>    // 每小时的第5分钟</p>
<p>0 8 <em> </em> *    // 每天8点</p>
<p>0 16,18,20,22 <em> </em> *    // 每天的16点、18点、20点、22点</p>
<p>0 1,18 <em> </em> *    // 每天的1点和18点</p>
<p>03 09 <em> </em> 1-5    // 工作日（周日到周五）的9点3分</p>
<p>59 23 <em> </em> 1-5 或者 @midnight    // 工作日（周日到周五）的9点3分</p>
<p>0 20 <em> </em> 1-5</p>
</blockquote>
<p>H 20 <em> </em> 1-5 周一到周五的每晚8点自动构建<br><img src="http://upload-images.jianshu.io/upload_images/2083649-7ff86e40cb556c71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="周期性触发配置"></p>
<h1 id="自定义环境变量获取Git-Log"><a href="#自定义环境变量获取Git-Log" class="headerlink" title="自定义环境变量获取Git Log"></a>自定义环境变量获取Git Log</h1><blockquote>
<p>构建触发器配置完成后,我们还可以通过Environment Injector Plugin(环境变量注入插件),目前用于获取gitLog,并传递给Fir.im上传信息).</p>
</blockquote>
<p>要先在Properties File Path 路径下创建一个对应的文件,否则改插件会报错找不到文件,名字可以自定义,但是要和Script Content的脚本内容中done&gt; 后面的文件及路径一致.<br><img src="http://upload-images.jianshu.io/upload_images/2083649-4c36eb4c4654bbc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置环境变量脚本"></p>
<p>我这里用于测试后期,只需要显示昨天Git提交的信息:</p>
<p>GIT_CHANGE_LOG=$(git log –after=”yesterday” –pretty=format:”%s”)</p>
<p>echo “GIT_CHANGE_LOG=$(git log –after=”yesterday” –pretty=format:”%s” | while read line</p>
<p>do </p>
<p>echo $line\\\\n | tr -d \n</p>
<p>done)”  ${WORKSPACE}/gitLogFile.properties</p>
<p>关于Git log的高级用法可以参考以下两篇文章:</p>
<p><a href="http://www.cnblogs.com/BeginMan/p/3577553.html" title="博客园-Git log高级用法" target="_blank" rel="external">博客园-Git log高级用法</a></p>
<p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.3-Git-log%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" title="Github-Git log 高级用法" target="_blank" rel="external">Github-Git log 高级用法</a></p>
<p>在构建中配置刚刚的文件路径,用户读取里面的环境变量打<br><img src="http://upload-images.jianshu.io/upload_images/2083649-ae552e1a05117ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在构建配置文件路径"></p>
<p>然后就可以在Fir插件上使用刚刚设置的环境变量${GIT_CHANGE_LOG}<br><img src="http://upload-images.jianshu.io/upload_images/2083649-aed8a25d8e40d731.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用环境变量 ${GIT_CHAGE_LOG}"></p>
<blockquote>
<p>构建分为Android和iOS构建,放在后面讲,先讲公共流程</p>
</blockquote>
<p>构建期还可以通过Sonar来进行代码质量检查,配置源码路径,支持java,oc,swift,php,javascript</p>
<blockquote>
<p>sonar.projectKey=xxx_Android_Key</p>
<p>sonar.projectName=xxx_Android_Name</p>
<p>sonar.projectVersion=$BUILD_NUMBER</p>
<p>sonar.sourceEncoding=UTF-8</p>
<p>sonar.sources=/Users/jz_mac_mini/xxx/xxx/app/src/main 静态代码目录(必选)</p>
<p>sonar.java.libraries=/Users/jz_mac_mini/xxx/xxx/app/libs/ 第三方库目录(必选)</p>
<p>sonar.java.binaries=/Users/jz_mac_mini/xxx/xxx/app/build/intermediates/classes/production/ 编译后的代码目录(必选)</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-b8b850104d5072e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目Sonar配置"></p>
<p>可以通过Sonar的后台查看代码分析<br><img src="http://upload-images.jianshu.io/upload_images/2083649-98889ea0a711aa70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sonar分析结果后台"></p>
<p>构建后使用Fir.im发布,先安装ruby,</p>
<blockquote>
<p>$ gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a> $ gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a> $ gem sources -l <strong><em> CURRENT SOURCES </em></strong> <a href="https://ruby.taobao.org" target="_blank" rel="external">https://ruby.taobao.org</a> # 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉</p>
<p>Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless , 无法直接安装 fir-cli, 有以下三种解决办法:</p>
<ol>
<li>使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐)</li>
</ol>
<h1 id="Install-Homebrew"><a href="#Install-Homebrew" class="headerlink" title="Install Homebrew:"></a>Install Homebrew:</h1><p>$ ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>
<h1 id="Install-RVM"><a href="#Install-RVM" class="headerlink" title="Install RVM:"></a>Install RVM:</h1><p>$ \curl -sSL <a href="https://get.rvm.io" target="_blank" rel="external">https://get.rvm.io</a> | bash -s stable –ruby</p>
<p>$ gem install fir-cli</p>
</blockquote>
<p>然后再通过插件配置Fir.im的账号,以及提交的fir的信息</p>
<blockquote>
<p>jenkins的build版本为:  $BUILD_NUMBER</p>
<p>git的提交版本  号 为 :  $GIT_COMMIT</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-a0282c1dc4955625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fir.im配置"></p>
<p>可以通过bearychat插件来配置通知群组,在项目中配置<br><img src="http://upload-images.jianshu.io/upload_images/2083649-5dee6977d906121e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bearychat项目配置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-f4b439f3a4c49603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bearychat通知打包结果"></p>
<p>可以配置邮件通知,使用插件来配置email-ext-plugin,可以定制发送的内容,</p>
<p>先配置smtp服务器</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-5bf68c263b129b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置SMTP服务器"><br>然后指定发给哪些邮箱地址,以及定制发送的内容</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-157f4d1ceafdd28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="邮件发送内容"></p>
<p>也可以使用自带的邮件通知,要先制定系统管理员邮件地址<br><img src="http://upload-images.jianshu.io/upload_images/2083649-70038b72c58536ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置管理员邮件地址"></p>
<p>然后再配置邮件服务器smtp<br><img src="http://upload-images.jianshu.io/upload_images/2083649-602532dab5417094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置自带邮件SMTP服务器"></p>
<h1 id="Android端构建配置"><a href="#Android端构建配置" class="headerlink" title="Android端构建配置"></a>Android端构建配置</h1><hr>
<p>Android SDK配置<br><img src="http://upload-images.jianshu.io/upload_images/2083649-907664fe4815d8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android SDK配置"></p>
<p>gradle可以指定本地的路径,也可以使用在线版本自动安装<br><img src="http://upload-images.jianshu.io/upload_images/2083649-9ce14831d2c90d70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle配置"></p>
<p>构建,可以通过Tasks来指定任务<br><img src="http://upload-images.jianshu.io/upload_images/2083649-fc0ac2fa2e4c20c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Task任务配置"></p>
<h1 id="iOS端构建配置"><a href="#iOS端构建配置" class="headerlink" title="iOS端构建配置"></a>iOS端构建配置</h1><hr>
<p>目前我们使用的是Xcode默认配置打包,不用jenkins上配置的证书及PP文件.有几个关键点要注意的.</p>
<p>首先要在Xcode把项目中Projec和Target的Code Signing 设置为iOS Developer,以及把PP设置为Automatic.<br><img src="http://upload-images.jianshu.io/upload_images/2083649-c9b39ae10a9c40ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Code Sign和PP文件设置"></p>
<p>然后在Product-&gt;Scheme-&gt;Manage Schemes 把项目设置为Shared,第三方库的不用设置<br><img src="http://upload-images.jianshu.io/upload_images/2083649-84e9d7c219bd9b3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="scheme设置"></p>
<p>系统管理-&gt;找到Keychain and Provisioning Profiles Management</p>
<blockquote>
<p>点击选择文件从本地选取Keychain,路径为:/Users/用户名/Library/Keychains/login.keychain</p>
</blockquote>
<p>这里我们目前的做法是只配置login.keychain,然后jenkins的机子上安装Code Signing证书,再在xcode项目上fix issue,就能够为我们自动生成一个PP文件,名为-iOS Team Provisioning Profiles : xxxx, 而且当我们在开发者中心更新设备列表的时候,此PP文件是会自动加入的.<br><img src="http://upload-images.jianshu.io/upload_images/2083649-6cf715e14895ceac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Keychain and Provisioning Profiles配置"></p>
<h1 id="针对CocoaPods设置"><a href="#针对CocoaPods设置" class="headerlink" title="针对CocoaPods设置"></a>针对CocoaPods设置</h1><hr>
<p>如果项目是使用CocoaPods来管理的,还要针对xcworkspace进行build的话,还要额外进行写设置</p>
<p>如果构建是出现编码错误的可以在~/.bash_profile文件加上一句</p>
<blockquote>
<p>export LC_ALL=”en_US.UTF-8”</p>
</blockquote>
<p>Xcode构建前,先用shell跑一遍pod install,我这里会出现pod: command not found 的错误,所以要在前面加上一句</p>
<blockquote>
<p>#!/bin/bash -l</p>
<p>pod install –verbose –no-repo-update</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2083649-8e81bbcba58e0818.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shell配置"></p>
<p>配置Workspace,红色的地方可以填上target名称,此处参考了<a href="http://www.pluto-y.com/jenkins-xcode-configuration/" title="章华龙的文章" target="_blank" rel="external">章华龙的文章</a>.<br><img src="http://upload-images.jianshu.io/upload_images/2083649-a3c2636440e185ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Workspace"></p>
<p>配置Workspace</p>
<h1 id="非CocoaPods设置"><a href="#非CocoaPods设置" class="headerlink" title="非CocoaPods设置"></a>非CocoaPods设置</h1><hr>
<p>配置Xcode<br><img src="http://upload-images.jianshu.io/upload_images/2083649-9196bc98b0d65a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Xcode构建"></p>
<p>这里可以填入keychain来解锁<br><img src="http://upload-images.jianshu.io/upload_images/2083649-94e742c8dba0e7e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解锁Keychain"></p>
<p>整个构建环境完成.</p>
<p>后期我们打算优化Sonar的检测分析,以及配置单元测试,UI测试,条件测试覆盖率等,继续往持续交付,持续部署的路上走!</p>
<p>Keep Going!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2083649-6bdfa1e51a834687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
    
    </summary>
    
      <category term="移动端" scheme="https://yidejia.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Jenkins" scheme="https://yidejia.github.io/tags/Jenkins/"/>
    
      <category term="黎进财" scheme="https://yidejia.github.io/tags/%E9%BB%8E%E8%BF%9B%E8%B4%A2/"/>
    
  </entry>
  
</feed>
